我们常常需要在一个异步任务执行完毕时，取消与其有关的另外一些异步任务。例如，我们可能希望一个IO请求超时后能及时终止。async-simple基于信号-槽模型，提供了一套通用，线程安全且高效的异步任务取消机制。并提供了结构化任务并发/取消支持。


## CancellationSignal 与 CancellationSlot

一个取消信号（CancellationSignal）可以被多个取消槽（CancellationSlot）注册。通常，当我们发起一组异步任务时，可以创建一个信号和多个槽，并给每一个异步任务都传递一个槽。各任务可以通过槽获取当前的取消状态。

```cpp
// 通过工厂方法创建信号
std::shared_ptr<CancellationSignal> signal = CancellationSignal::create();
std::vector<std::future<void>> works;
for (int i=0;i<10;++i) {
  // 为每一个异步任务创建槽
  auto slot = std::make_unique<CancellationSlot>(signal.get());
  // 异步执行任务
  std::async(std::launch::async, [slot=std::move(slot)] {
      // 手动轮询取消状态
      while (!slot->canceled()) {
        // ...
      }
      return;
  });
}
// ...
// 提交取消信号
signal->emit(CancellationType::terminal);
for (auto &e:works)
  e.get();
```

除了直接查询取消状态，异步任务也可以在执行异步操作前，在取消槽中注册一个回调函数，它不应该阻塞，并且能够通知异步任务停止等待。触发取消信号的线程会执行所有绑定在信号上的槽。例如，下面这段代码通过注册回调函数取消睡眠。

```cpp
// 通过工厂方法创建信号
std::shared_ptr<CancellationSignal> signal = CancellationSignal::create();
std::vector<std::future<void>> works;
for (int i=0;i<10;++i) {
  // 为每一个异步任务创建槽
  auto slot = std::make_unique<CancellationSlot>(signal.get());
  // 异步执行任务
  std::async(std::launch::async, [slot=std::move(slot)] {
      std::unique_ptr<std::promise<void>> p;
      auto f = p->get_future();
      book ok = slot->emplace([p=std::move(p)](CancellationType type){
          p->set_value();
      });
      if (ok) { //如果取消信号还未触发
          f.wait_for(1s*(rand()+1)); // 除非取消信号被触发，否则睡觉睡眠一段时间。
      }
      slot->clear(); // 清除回调函数
      if (slot->signal()) { //如果槽被绑定在信号上
          slot->signal()->emit(CancellationType::terminal); // 触发取消信号。
      }
      return;
  });
}
// ...
// 第一个异步定时任务结束后其他任务也会一起结束。
for (auto &e:works)
  e.get();
```

上述代码中，我们通过调用槽的`signal()`函数可以获取到指向信号的指针。我们保证该函数返回的指针总是合法的，因为信号的生命周期会被自动延长到最后一个绑定的槽析构之后。

上述代码可能会多次调用`emit`函数尝试触发取消信号，我们保证这种情况下取消信号只会被触发一次，后面的`emit`调用会返回`false`。此外，对于`CancellationSignal`的所有操作都是线程安全的。


```cpp
class CancellationSignal
    : public std::enable_shared_from_this<CancellationSignal> {
public:
    // 提交一个信号，第二次调用会失败返回false，线程安全。
    bool emit(CancellationType state) noexcept;
    // 判断信号是否已经提交过，线程安全。
    bool hasEmited() noexcept;
    // 获取当前的取消信号，线程安全
    CancellationType state() const noexcept;
    // 创建信号的唯一方法，返回一个shared_ptr
    static std::shared_ptr<CancellationSignal> create();
};
```

各异步任务应持有各自的`CancellationSlot`，因此槽对象不是线程安全的。我们禁止用户并发调用槽提供的公共接口。

```cpp
enum class CancellationType;
class CancellationSlot {
    // 将信号与槽绑定在一起。可以指定信号过滤级别，如果取消信号type & filter为0，则信号不会被触发。
    CancellationSlot(CancellationSignal* signal,
                     CancellationType filter = CancellationType::all);
    // 注册一个信号处理函数，返回false: 取消信号已经触发。用户可以多次注册信号处理函数。
    template <typename... Args>
    [[nodiscard]] bool emplace(Args&&... args);
    // 清空信号处理函数，如果返回false说明信号处理函数已经被执行，或尚未注册过信号。
    bool clear();
    // 在指定作用域内过滤信号，如果取消信号type & filter为0，则信号type在该作用域内不会被触发。
    // 允许嵌套的添加filter。
    [[nodiscard]] FilterGuard addScopedFilter(CancellationType filter);
    // 获取当前作用域的filter
    CancellationType getFilter();
    // 判断被过滤后的取消信号是否处于触发状态。
    bool canceled() const noexcept;
    // 判断回调函数是否已经开始执行或执行完毕。和cancel()不同的是，如果在注册回调函数之前取消信号已经触发，该函数会返回false而不是true。
    bool hasStartExecute() const noexcept;
    // 该函数返回槽对应的信号，如果在构造槽之前取消信号已经触发，则该函数返回nullptr。否则始终返回一个有效的信号指针。这是因为slot持有对应的singal的所有权。
    // 如果想要延长signal的生命周期，可以调用signal()->shared_from_this()，也可以用signal启动一个新协程。
    CancellationSignal* signal() const noexcept;
};
enum class CancellationType : uint64_t {
    none = 0,
                                      // 剩余bit保留给用户自定义扩展。
    terminal = 0x8000'0000'0000'0000, // 默认的取消信号
    all = 0xffff'ffff'ffff'ffff,      // 默认过滤级别（不过滤任何信号）
};
```

## 无栈协程支持

上述的槽与信号是较为低级的通用api，可适配各种异步场景。在async-simple无栈协程库`Lazy`中，提供了一系列高级封装支持，使得用户无需关心细节，也能实现结构化并发任务的取消操作。

### collect函数与结构化并发

在一般用户代码中，我们建议使用`collectAny`和`collectAll`来实现结构化并发任务的取消操作。

#### collectAny

`collectAny`可以并发执行多个协程，并等待第一个协程返回。`collectAny`会自动将这些协程绑定到一个取消信号，并在第一个协程执行完毕时，向其他尚未执行完毕的协程发送取消信号，从而结束这些任务。

例如，下面是使用`collectAny`实现通用的超时处理逻辑的代码。
```cpp
Lazy<void> sleep_1s();
Lazy<std::string> async_read();
auto res = co_await collectAny(async_read(),sleep_1s());
if (std::get<res>() == 1) { // timed out!
  // ...
}
else {
  // ...
}
```

`collectAny`支持用户发送不同的取消信号。默认发送的取消信号是`CancellationType::terminal`,如果不想让`collectAny`取消其他任务，则可以选择发送信号`CancellationType::none`
```cpp
Lazy<void> work1();
Lazy<void> work2();
auto res = co_await collectAny<CancellationType::none>(async_read(),sleep_1s());
if (std::get<res>() == 0) { 
  // work1 finished, work2 will still working
}
else { 
  // work2 finished, work1 will still working
}
```

#### collectAll

和`collectAny`相同，`collectAll`也支持在第一个任务结束时发送取消信号。不同之处在于：

1. 默认情况下collectAll发送`CancellationType::none`信号（因此默认情况下不会取消其他任务）

```cpp
Lazy<int> work1();
Lazy<std::string> work2();
// work1(), work2() all finished, no cancel
auto res = co_await collectAll(work1(),work2());
// work1(), work2() all finished, the later work will be canceled by CancellationType::terminal
auto res = co_await collectAll<CancellationType::terminal>(work1(),work2());
```

2. collectAll会等待协程执行完毕，并获取返回值。一方面，这简化了异步任务的生命周期。另一方面，如果取消信号没能中止任务，`collectAll`会等待其他任务执行完毕。

```cpp
http_client client;
// 和collectAny不同， 我们无需通过引用计数延长client的生命周期，因为collectAll保证一定会等待http_client::connect协程返回。
auto res = co_await collectAll(client.connect("localhost:8080"), sleep(1s));
```

### 信号槽的传递与获取

一个`Lazy`可以持有一个`CancellationSlot`, 当我们想要为一个异步任务绑定取消信号时，只需要在任务开始阶段，通过`Lazy<T>::setLazyLocal`来绑定信号，它会随着`co_await`一路传递下去。需要注意的是，信号只能绑定一次。

我们可以通过`co_await CurrentCancellationSlot{}` 来获取指向`CancellationSlot`的指针，调用`co_await ForbidCancellation{}`会让协程调用链与取消信号解绑，从而防止后续任务被中止。它会析构对应的`CancellationSlot`对象，并且之后调用`co_await CurrentCancellationSlot{}`会返回nullptr。

```cpp
Lazy<void> subTask() {
    CancellationSlot* slot = co_await CurrentCancellationSlot{};
    assert(slot!=nullptr);
    co_await ForbidCancellation{};
    // slot is illegal now.
    assert(co_await CurrentCancellationSlot{} == nullptr);
    co_returnl
}
Lazy<void> Task() {
    CancellationSlot* slot = co_await CurrentCancellationSlot{};
    assert(slot!=nullptr);
    co_await subTask();
    assert(co_await CurrentCancellationSlot{} == nullptr);
    co_return;
}
auto signal = CancellationSignal::create();
syncAwait(Task().setLazyLocal(signal.get()).via(ex));
```

### 支持取消操作的对象与函数

除了手动判断取消信号是否被触发，async-simple许多可能挂起的函数都为取消操作提供了支持。

以下各对象与函数支持取消操作，被取消的协程可能抛出异常`std::system_error`，其错误码为`std::errc::operation_canceled`. 此外，所有函数在挂起/恢复协程时都会自动插入两个检查点判断任务是否被取消。
1. CollectAny：被取消时会将信号转发给所有子任务，并抛出异常立即返回。
2. CollectAll：被取消时会将信号转发给所有子任务，随后等待所有子任务执行完毕后正常返回。
3. Yield/SpinLock/Latch：如果被取消，会抛出异常。目前暂不支持取消在调度器中排队的任务。
4. Sleep: 依赖于调度器是否重写了虚函数`void schedule(Func func, Duration dur, uint64_t schedule_info, CancellationSlot *slot = nullptr)`，并正确实现了取消功能。如果未重写该函数，则async_simple的默认实现支持取消睡眠。

以下IO对象与函数暂未支持取消操作，有待后续完善。
1. Mutex
2. ConditionVariable
3. SharedMutex
4. Latch
5. Promise/Future
6. CountingSemaphore

### 自定义Awaiter如何支持取消

用户在实现自己的IO函数时，也需要适配支持取消功能。async_simple提供了`CancellationSlot::ready()`，`CancellationSlot::suspend()`和`CancellationSlot::resume()`等辅助函数来简化用户代码。

下面我们提供一个将异步定时器封装为基于协程的Sleep函数并支持取消功能的示例：

```cpp
using Duration = std::chrono::millseconds;
class TimeAwaiter {
public:
    TimeAwaiter(Duration dur, CancellationSlot *slot)
        : _asyncTimer(), _dur(dur), _slot(slot) {}

public:
    bool await_ready() const noexcept { 
      // check if canceled before suspend  (if canceled, call await_resume() immediately)
      return CancellationSlot::ready(_slot); 
    }

    bool await_suspend(std::coroutine_handle<> handle) {
        bool hasnt_canceled = CancellationSlot::suspend(
            slot, [this](CancellationType) {
                _asyncTimer.cancel();
            });
        if (hasnt_canceled) {
            _asyncTimer.sleep_for(_dur, [](auto&&){
                handle.resume();
            })
        }
        else {
            return true; // resume now
        }
    }

    // check if canceled after suspend (if canceled, throw exception), if not canceled, clear slot function.
    void await_resume() { 
      CancellationSlot::resume</*if canceled callback is running, waiting for cancel finished = */true>(_slot); 
    }

    // helper function to speed-up Lazy co_await (it will ignore lazy's executor)
    auto coAwait(Executor *) {
        return *this;
    }

private:
    AsyncTimer _asyncTimer;
    Duration _dur;
    CancellationSlot *_slot;
};

// throw exception if canceled.
template <typename Rep, typename Period>
Lazy<void> my_sleep(Duration dur) {
    co_return co_await TimeAwaiter{dur,co_await CurrentCancellationSlot{}};
}
```

需要注意的是，槽函数只捕获了this指针，无需延长timer生命周期，这是因为在`resume`时，如果发现正在执行槽函数，会同步等待槽函数执行完成。由此我们保证槽函数会在对象析构之前运行完毕。如果不想同步等待，则需要通过引用计数等机制延长`timer`的生命周期，防止睡眠结束的同时发起的取消信号，导致`TimerAwaiter`析构后才执行`timer.cancel()`

## 有栈协程支持

有栈协程暂未对取消做特殊支持，待后续完善。

